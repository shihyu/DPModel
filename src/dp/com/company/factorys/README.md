#工廠方法模式(Factory Pattern) 
定義：Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses。定義一個用於創建對象的接口，讓子類決定實例化哪一個類。工廠方法使一個類的實例化延遲到其子類。

工廠方法模式的類圖如下圖：  
![Alt text](factorys.jpg "工廠方法模式類圖")


在工廠方法模式中，抽象產品類Product負責定義產品的共性，實現對事物最抽象定義；Creator為抽象創建類，也就是抽象工廠，具體如何創建產品類是由具體的實現工廠ConcreteCreator完成的。工廠方法模式的變種較多。    


#工廠方法模式的應用
##1.工廠方法模式的優點
 * 首先，良好的封裝性，代碼結構清晰。一個對象創建是有條件約束的，如一個調用者需要一個具體的產品對象，只要知道這個產品的類名（或約束字符串）就可以了，不用知道創建對象的艱辛過程，減少模塊間的耦合。
 * 其次，工廠方法模式的擴展性非常優秀。在增加產品類的情況下，只要適當地修改具體的工廠類或擴展一個工廠類，就可以完成“擁抱變化”。
 * 再次，屏蔽產品類。這一特點非常重要，產品類的實現如何變化，調用者都不需要關心，它只需要關心產品的接口，只要接口保持不表，系統中的上層模塊就不要發生變化，因為產品類的實例化工作是由工廠類負責，一個產品對象具體由哪一個產品生成是由工廠類決定的。在數據庫開發中，大家應該能夠深刻體會到工廠方法模式的好處：如果使用JDBC連接數據庫，數據庫從MySql切換到Oracle，需要改動地方就是切換一下驅動名稱（前提條件是SQL語句是標準語句），其他的都不需要修改，這是工廠方法模式靈活性的一個直接案例。
 * 最後，工廠方法模式是典型的解耦框架。高層模塊值需要知道產品的抽象類，其他的實現類都不用關心，符合迪米特原則，我不需要的就不要去交流；也符合依賴倒轉原則，只依賴產品類的抽象；當然也符合里氏替換原則，使用產品子類替換產品父類，沒問題！


##2.工廠方法模式的使用場景 
 * 首先，工廠方法模式是new一個對象的替代品，所以在所有需要生成對象的地方都可以使用，但是需要慎重地考慮是否要增加一個工廠類進行管理，增加代碼的複雜度。
 * 其次，需要靈活的、可擴展的框架時，可以考慮採用工廠方法模式。萬物皆對象，那萬物也就皆產品類，例如需要設計一個連接郵件服務器的框架，有三種網絡協議可供選擇：POP3、IMAP、HTTP，我們就可以把這三種連接方法作為產品類，定義一個接口如IConnectMail，然後定義對郵件的操作方法，三個具體的產品類（也就是連接方式）進行不同的實現，再定義一個工廠方法，按照不同的傳入條件，選擇不同的連接方式。如此設計，可以做到完美的擴展，如某些郵件服務器提供了WebService接口，很好，我們只要增加一個產品類就可以了。
 * 再次，工廠方法模式可以用在異構項目中，例如通過WebService與一個非Java的項目交互，雖然WebService號稱是可以做到異構系統的同構化，但是在實際的開發中，還是會碰到很多問題，如類型問題、WSDL文件的支持問題，等等，從WSDL中產生的對象都認為是一個產品，然後由一個具體的工廠類進行管理，減少與外圍系統的耦合。
 * 最後，可以使用在測試驅動開發的框架下，例如，測試一個類A，就需要把與類A有關聯關係的類B也同時產生出來，我們可以使用工廠方法模式把類B虛擬出來，避免類A與類B的耦合。目前由於JMock和EasyMock的誕生，該使用場景已經弱化了，讀者可以在遇到此種情況時直接考慮使用JMock或EasyMock。 


#工廠方法模式的擴展
 * 縮小為簡單工廠模式
 * 升級為多個工廠類
 * 替代單例模式
 * 延遲初始化。何為延遲初始化(Lazy initialization)?一個對象被消費完畢後，並不立刻釋放，工廠類保持其初始狀態，等待再次被使用。延遲初始化是工廠方法模式的一個擴展應用。