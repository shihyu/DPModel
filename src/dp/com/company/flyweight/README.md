#享元模式(Flyweight Pattern) 
定義：Use sharing to support large numbers of fine-grained objects efficiently.(使用共享對象可有效地支持大量的細粒度的對象。)  

享元模式的定義為我們提出了兩個要求：細粒度的對象和共享對象。要求細粒度對象，那麼不可避免地使得對象數量多且性質相近，那我們就將這些對象的信息分為兩個部分：內部狀態(intrinsic)與外部狀態(extrinsic)。

- 內部狀態：內部狀態是對象可共享出來的信息，存儲在享元對象內部並且不會隨環境改變而改變。
- 外部狀態：外部狀態是對象得以依賴的一個標記，是隨環境改變而改變的、不可以共享的狀態。


 享元模式的通用類圖如圖所示。  
![Alt text](flyweight.gif "享元模式類圖")


我們先來看我們享元模式角色名稱。

- Flyweight抽象享元角色：它簡單地說就是一個產品的抽象類，同時定義出對象的外部狀態和內部狀態的接口和實現。
- ConcreteFlyweight具體享元角色：具體的一個產品類，實現抽象角色定義的業務。該角色中需要注意的是內部狀態處理應該與環境無關，不應該出現一個操作改變了內部狀態，同時修改了外部狀態，這是絕對不允許的。
- UnsharedConcreteFlyweight不可共享的享元角色：不存在外部狀態或者安全要求不能夠使用共享技術的對象，該對象一般不會出現在享元工廠中。
- FlyweightFactory享元工廠：職責非常簡單，就是構造一個池容器，同時提供從池中獲得對象的方法。

享元模式的目的在於運用共享技術，使得一些細粒度的對象可以共享，我們的設計確實也應該這樣，多使用細粒度的對象，便於重構或重用。  


#享元模式的應用
##1.享元模式的優點和缺點
享元模式是一個非常簡單的模式，它可以大大減少應用程序創建的對象，降低程序內存的佔用，增強程序的性能，但它同時也提高了系統複雜性，需要分離外部狀態和內部狀態，而且外部狀態具有固化特性，不應該隨內部狀態改變而改變，否則導致系統的邏輯混亂。  


##2.享元模式的缺點 
 * 享元模式會引起類膨脹：每個語法都要產生一個非終結符表達式，語法規則比較複雜時，就可能產生大量的類文件，為維護帶來了非常多的麻煩。
 * 享元模式採用遞歸調用方法：每個非終結符表達式只關心與自己有關的表達式，每個表達式需要知道最終的結果，必須一層一層地剝繭，無論是面向過程的語言還是面向對象的語言，遞歸都是在必要條件下使用的，它導致調試非常複雜。想想看，如果要排查一個語法錯誤，我們是不是要一個一個斷點的調試下去，直到最小的語法單元。
 * 效率問題：享元模式由於使用了大量的循環和遞歸，效率是個不容忽視的問題，特別是用於解析複雜、冗長的語法時，效率是難以忍受的。  


##3.享元模式的使用場景
 * 系統中存在大量的相似對象。
 * 細粒度的對象都具備較接近的外部狀態，而且外部狀態與環境無關，也就是說對象沒有特定身份。
 * 需要緩衝池的場景。