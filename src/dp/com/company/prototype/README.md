#原型模式(Proxy Pattern) 
定義：Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype. 用原型實例指定創建對象的種類，並且通過拷貝這些原型創建新的對象。  

原型模式的通用類圖如下圖：  
![Alt text](prototype.gif "原型模式類圖")

原型模式的核心是一個clone方法，通過該方法進行對象的拷貝，Java提供了一個Cloneable接口來標示這個對象是可拷貝的，為什麼說是“標示”呢？翻開JDK的幫助看看Cloneable是一個方法都沒有的，這個接口只是一個標記作用，在JVM中具有這個標記的對象才有可能被拷貝，那怎麼才能從“有可能被拷貝”轉換為“可以被拷貝”呢？方法是覆蓋clone()方法。實現一個接口，然後重寫clone方法，就完成了原型模式！  


#原型模式的應用
##原型模式的優點
 * 性能優良。原型模式是在內存二進制流的拷貝，要比直接new一個對象性能好很多，特別是要在一個循環體內產生大量的對象時，原型模式可以更好的體現其優點。 
 * 逃避構造函數的約束。這既是它的優點也是缺點，直接在內存中拷貝，構造函數是不會執行的（見“原型模式的注意事項”），優點就是減少了約束，缺點也是減少了約束，雙刃劍，需要大家在實際應用時考慮。


##原型模式的使用場景
 * 資源優化場景。類初始化需要消化非常多的資源，這個資源包括數據、硬件資源等。
 * 性能和安全要求的場景。通過new產生一個對象需要非常繁瑣的數據準備或訪問權限，則可以使用原型模式。
 * 一個對象多個修改者的場景。一個對象需要提供給其他對象訪問，而且各個調用者可能都需要修改其值時，可以考慮使用原型模式拷貝多個對象供調用者使用。 
 
在實際項目中，原型模式很少單獨出現，一般是和工廠方法模式一起出現，通過clone的方法創建一個對象，然後由工廠方法提供給調用者。原型模式已經與Java融為渾然一體，大家可以隨手拿來使用。       

 
#原型模式的注意事項
 * 構造函數不會被執行。
 * 淺拷貝和深拷貝。Object類提供的方法clone只是拷貝本對象，其對象內部的數組、引用對象等都不拷貝，還是指向原生對象的內部元素地址，這種拷貝就叫做淺拷貝，確實是非常淺，兩個對象共享了一個私有變量，你改我改大家都能改，是一種非常不安全的方式，在實際項目中使用還是比較少的（當然，這是也是一種“危機”環境的一種救命方式）。內部的數組和引用對象才不拷貝，其他的原始類型比如int,long,String(Java就希望你把String認為是基本類型，String是沒有clone方法的)等都會被拷貝的。(注意：使用clone方法拷貝時，滿足兩個條件的對象才不會被拷貝：一是類的成員變量，而不是方法內的變量；二是必須是一個對象，而不是一個原始類型)
 * clone與final兩對冤家。對象的clone與對象內的final關鍵字是有衝突的。要使用clone方法，類的成員變量上不要增加final關鍵字。