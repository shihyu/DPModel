#代理模式(Proxy Pattern) 
定義：provide a surrogate or placeholder for another object to control access to it.為其他對象提供一種代理以控制對這個對象的訪問。  

代理模式的通用類圖如下圖：  
![Alt text](proxy.jpg "代理模式類圖")

代理模式也叫做委託模式，它是一項基本設計技巧，許多其他的模式，如狀態模式、策略模式、訪問者模式本質上是在更特殊的場合採用了委託模式，而且在日常的應用中，代理模式可以提供非常好的訪問控制，在一些著名開源軟件中也經常見到它的身影，如Struts2的Form元素映射就採用了代理模式（準確的說是動態代理模式）。我們先看一下類圖中的三個角色的定義：

- Subject抽象主題角色。抽象主題類可以是抽象類也可以是接口，是一個最普通的業務類型定義，無特殊要求。
- RealSubject 具體主題角色。也叫做被委託角色、被代理角色，它才是冤大頭，是業務邏輯的具體執行者。 
- Proxy代理主題角色。也叫做委託類、代理類，它負責對真實角色的應用，把所有抽象主題類定義的方法限制委託給真實主題角色實現，並且在真實主題角色處理完畢前後做預處理和善後處理工作。

#代理模式的應用
##代理模式的優點
 * 職責清晰。真實的角色就是實現實際的業務邏輯，不用關心其他非本職責的事務，通過後期的代理完成一件完成事務，附帶的結果就是編程簡潔清晰。 
 * 高擴展性。具體主題角色是隨時都會發生變化的，只要它實現了接口，甭管它如何變化，都逃不脫如來佛的手掌（接口），那我們的代理類完全就可以在不做任何修改的情況下使用。
 * 智能化。這在我們以上講解中還沒有體現出來，不過在我們以下的動態代理章節中你就會看到代理的智能化，讀者有興趣也可以看看Struts是如何把表單元素映射到對象上的。 
 
##代理模式的應用
我相信第一次接觸到代理模式的讀者肯定很鬱悶，為什麼要用代理呀，是的，為什麼要用代理？想想現實世界吧，你為什麼要找代理律師，你去打官司，為什麼要找個律師？因為你不想參與中間過程的是是非非，只要完成自己的答辯就成，其他的比如事前調查、事後追查都由律師來搞定，這就是為了減輕你的負擔。代理模式使用非常多，大家可以看看Spring AOP，這是一個非常典型的動態代理。  

 
#代理模式的擴展
##普通代理
 在網絡上代理服務器設置分為透明代理和普通代理，是什麼意思呢？透明代理就是用戶不用設置代理服務器地址，就可以直接訪問，也就是說代理服務器對用戶來說透明的，看不到，不用知道它存在的；普通代理則是需要用戶自己設置代理服務器的IP地址，用戶必須知道代理的存在。我們設計模式中的普通代理和強制代理也是類似的一種結構，普通代理就是我們要知道代理的存在，也就是類似的GamePlayerProxy這個類的存在，然後才能訪問；強制代理則是調用者直接調用真實角色，而不用關心代理是否存在，其代理的產生是由真實角色決定的，這樣解釋還是比較複雜，我們還是用實例來講解。  

首先說普通代理，它的要求就是客戶端只能訪問代理角色，而不能訪問真實角色。在該模式下，調用者只知代理而不用知道真實的角色是誰，屏蔽了真實角色的變更對高層模塊的影響，真實的主題角色愛怎麼修改就怎麼修改，對高層次的模塊沒有任何的影響，只要你實現了接口所對應的方法，該模式非常適合對擴展性要求較高的場合。當然，在實際的項目中，一般都是通過約定來禁止new一個真實的角色，也是一個非常好的方案。  

    注意：普通代理模式的約束問題，儘量通過團隊內的編程規範類約束，因為每一個主題類是可被重用的和可維護的，使用技術約束的方式對系統維護是一種非常不利的因素。


##強制代理
強制代理在設計模式中比較另類，為什麼這麼說呢？一般的思維都是通過代理找到真實的角色，但是強制代理卻是要“強制”，你必須通過真實角色查找到代理角色，否則你不能訪問，甭管你是通過代理類還是通過直接new一個主題角色類，都不能訪問，只有通過真實角色指定的代理類才可以訪問，也就是說由真實角色管理代理角色，這麼說吧，高層模塊new了一個真實角色的對象，返回的卻是代理角色。  

強制代理的概念就是要從真實角色查找到代理角色，不允許直接訪問真實角色，高層模塊只要調用getProxy就可以訪問真實角色的所有方法，它根本就不需要產生一個代理出來，代理的管理已經由真實角色自己完成。  


##代理是有個性的
一個類可以實現多個接口，完成不同任務的整合，那也就是說代理類不僅僅可以實現主題接口，也可以實現其他接口完成不同的任務，而且代理的目的是在目標對象方法的基礎上作增強，這種增強的本質通常就是對目標對象的方法進行攔截和過濾。例如遊戲代理是需要收費的，升一級需要5元錢，這個計算功能就是代理類的個性，它應該在代理的接口中定義。  


##虛擬代理
虛擬代理(Virual Proxy)只要我們把代理模式的通用代碼稍微修改一下就成為虛擬代理。在需要的時候才初始化主題對象，可以避免被代理對象較多而引起的初始化緩慢的問題，它的缺點就是需要在每個方法中判斷主題對象是否被創建，這就是虛擬代理，非常簡單。  


##動態代理
動態代理模式的通用類圖如下圖：  
![Alt text](dynamicproxy.jpg "動態代理模式類圖")

動態代理是在實現階段不用關心代理誰，而在運行階段才指定代理那一個對象，相對的來說，自己寫代理類的方式就是靜態代理。現在有一個非常流行的名稱叫做：面向橫切面編程，也就是AOP（Aspect Oriented Programming），其核心就是採用了動態代理機制。  

在類圖中有一個InvocationHanlder接口，是JDK提供的動態代理接口，對被代理類的方法進行代理。其中invoke方法是接口InvocationHandler定義必須實現的，它完成對真實方法的調用。我們來詳細講解一下InvocationHanlder接口，動態代理是根據被代理的接口生成所有的方法，也就是說給定一個接口，動態代理會宣稱“我已經實現該接口下的所有方法了”，那各位讀者想想看，動態代理怎麼才能實現被代理接口中的方法呢？默認情況下所有的方法返回值都是空的，是的，代理已經實現它了，但是沒有任何的邏輯含義，那怎麼辦？好辦，通過InvocationHandler接口，所有方法都由該Handler來進行處理，即所有被代理的方法都由InvocationHandler接管實際的處理任務。  

     注意：要實現動態代理的首要條件是：被代理類必須實現一個接口。當然了，現在也有很多技術如CGLIB可以實現不需要接口也可以實現動態代理的方式。  

再次說明，以上的動態代理是一個通用代理框架，如果你想設計自己的AOP框架，完全可以在此基礎上擴展，我們設計的是一個通用代理，只要有一個接口，一個實現類，就可以使用該代理，完成代理的所有功效。