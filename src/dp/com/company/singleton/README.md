#單例模式(Singleton Pattern) 
定義：Ensure a class has only one instance, and provide a global point of access to it. 確保某一個類只有一個實例，而且自行實例化並向整個系統提供這個實例。   
Singleton類稱為單例類，通過使用private的構造函數，確保了在一個應用中只產生一個實例，並且是自行實例化的（在Singleton中自己使用new Singleton()）。  

單例模式的通用類圖如下圖：  
![Alt text](singleton.gif "單例模式類圖")


#單例模式應用
##1.單例模式的優點
 * 由於單例模式在內存中只有一個實例，減少了內存開支，特別是一個對象需要頻繁的被創建、銷燬，而且創建或銷燬時性能又無法優化，單例模式的優勢就非常明顯；
 * 由於單例模式只生成一個實例，減少了系統性能開銷，當一個對象的產生需要比較多的資源時，如讀取配置、產生其他依賴對象時，則可以通過在應用啟動時直接產生一個單例對象，然後永久駐留內存的方式來解決（在Java EE中採用單例模式時需要注意JVM垃圾回收機制）；
 * 單例模式可以避免對資源的多重佔用，例如一個寫文件動作，由於只有一個實例存在內存中，避免對同一個資源文件的同時寫操作。
 * 單例模式可以在系統設置全局的訪問點，優化環共享資源訪問，例如可以設計一個單例類，負責所有數據表的映射處理。


##2.單例模式的缺點 
 * 單例模式沒有接口，擴展很困難，若要擴展，除了修改代碼沒有第二種途徑可以實現。單例模式為什麼不能增加接口呢？因為接口對單例模式是沒有任何的意義，它要求“自行實例化”，並且提供單一實例、接口或抽象類是不可能被實例化的。
 * 單例模式對測試是不利的。在並行開發環境中，如果單例模式沒有完成，是不能進行測試的，沒有接口也不能使用mock的方式虛擬一個對象。
 * 單例模式與單一職責原則有衝突。一個類應該只實現一個的邏輯，而不關心它是否是單例的，決定它是不是要單例是環境決定的，單例模式把“要單例”和業務邏輯融合也在一個類中。


##3.單例模式的使用場景
 * 要求生成唯一序列號的環境；
 * 在整個項目中需要有訪問一個共享訪問點或共享數據，例如一個Web頁面上的計數器，可以不用每次刷新都記錄到數據庫中，使用單例模式保持計數器的值，並確保是線程安全的；
 * 創建一個對象需要消耗的資源過多，如要訪問IO、訪問數據庫等資源；
 * 需要定義大量的靜態常量和靜態方法（如工具類）的環境，可以採用單例模式（當然，也可以直接聲明為static的方式）；


#單例模式的擴展
需要產生固定數量對象的模式就叫做有上限的多例模式，它是單例模式的一種擴展，採用有上限的多例模式，我們可以在設計時決定在內存中有多少個實例，方便系統進行擴展，修正單例可能存在的性能問題，提供系統的響應速度。例如讀取文件，我們可以在系統啟動時完成初始化工作，在內存中啟動固定數量的reader實例，然後在需要讀取文件時就可以快速響應。  


#最佳實踐
單例模式是23個模式中比較簡單的模式，應用也非常廣泛，如在Spring中，每個Bean默認就是單例的，這樣做的優點是Spring容器可以管理這些Bean的生命期，決定什麼時候創建出來，什麼時候銷燬，銷燬的時候要如何處理，等等。如果採用非單例模式（Prototype類型），則Bean初始化後的管理則交由J2EE容器，Spring容器不再跟蹤管理Bean的生命週期。  
使用單例模式需要注意的一點就是JVM的垃圾回收機制，如果我們的一個單例對象在內存中長久不使用，JVM就認為這個對象是一個垃圾，在CPU資源空閒的情況下該對象會被清理掉，下次再調用時就需要重新產生一個對象。如果我們在應用中使用單例類作為有狀態值（如計數器）的管理，則會出現回覆原狀的情況，應用就會出現故障。如果確實需要採用單例模式來記錄有狀態的值，有兩種辦法可以解決該問題：


- 由容器管理單例的生命週期  
- 狀態隨時記錄:可以使用異步記錄的方式，或者使用觀察者模式，記錄狀態的變化，寫入文件或寫入數據庫中，確保即使單例對象重新初始化也可以從資源環境獲得銷燬前的數據，避免應用數據丟失。 