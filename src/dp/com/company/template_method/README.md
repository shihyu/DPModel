#模板方法模式(Template Method Pattern) 
定義：Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure。定義一個操作中的算法的骨架，而將一些步驟延遲到子類中。使得子類可以不改變一個算法的結構即可重定義該算法的某些特定步驟。  

模板方法模式的通用類圖如下圖：  
![Alt text](template.jpg "模板方法模式類圖")

模板方法模式確實非常簡單，僅僅使用了Java的繼承機制，但是它是一個應用非常廣泛的模式。其中，AbstractClass叫做抽象模板，它的方法分為兩類：

- 基本方法。基本方法也叫做基本操作，是由子類實現的方法，並且在模板方法被調用。
- 模板方法。可以有一個或幾個，一般是一個具體方法，也就是一個骨架，實現對基本方法的調度，完成固定的邏輯。

在類圖中還有一個角色：具體模板，ConcreteClass1和ConcreteClass2屬於具體模板，實現父類所定義的一個或多個抽象方法，也就是父類定義的基本方法在子類中得以實現。  

     注意：為了防止惡意的操作，一般模板方法都加上final關鍵字，不允許被覆寫。  

#模板方法模式的應用
##模板方法模式的優點
 * 封裝不變部分，擴展可變部分。把認為是不變部分的算法封裝到父類實現，而可變部分的則可以通過繼承來繼續擴展。我們悍馬模型例子中，是不是就非常容易擴展，例如增加一個H3型號的悍馬模型，很容易呀，增加一個子類，實現父類的基本方法就可以了。
 * 提取公共部分代碼，便於維護。我們例子中剛剛走過的彎路就是最好的證明，如果我們不抽取到父類中，任由這種散亂的代碼發生，想想後果是什麼樣子？維護人員為了修正一個缺陷，需要到處查找類似的代碼！
 * 行為控制交由子類來實現。基本方法是由子類實現的，因此子類可以通過擴展的方式增加相應的功能，符合開閉原則。
 
 
##模板方法模式的缺點
按照我們設計習慣，抽象類負責聲明最抽象、最一般的事物屬性和方法，實現類完成具體的事物屬性和方法，但是模板方法模式卻顛倒了，抽象類定義了部分抽象方法，由子類實現，子類執行的結果影響了父類的結果，也就是子類對父類產生了影響，這在複雜的項目中，會帶來代碼閱讀的難度，而且也會讓新手產生不適感。  
       

#模板方法模式的使用場景
 * 多個子類有公有的方法，並且邏輯基本相同時。
 * 重要、複雜的算法，可以把核心算法設計為模板方法，周邊的相關細節功能則由各個子類實現。
 * 重構時，模板方法模式是一個經常使用的模式，把相同的代碼抽取到父類中，然後通過鉤子函數（見“模板方法模式的擴展”）約束其行為。            